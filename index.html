<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Cahill–Concialdi Projection</title>
</head>
<style>

html, body {
  margin: 0;
  padding: 0;
  background: #000;
}

svg, canvas {
  position: absolute;
  width: 100vw;
}

</style>
<body>

<canvas></canvas>
<svg>
  <style>
#background {
  fill: #123;
  stroke: none;
}

#graticule {
  fill: none;
  stroke-width: 0.15;
  stroke: #246;
}

#circles {
  fill: none;
  stroke-width: 0.3;
  stroke: #357;
}

.polar-tropic {
  stroke-dasharray: 1 1;
}

#countries {
  stroke-width: 0.01;
  stroke-linejoin: round;
}

#countries path:hover {
  fill: #ff8;
}

#boundaries {
  fill: none;
  stroke: #234;
  stroke-width: 0.1;
  stroke-linejoin: round;
  stroke-linecap: round;
}

#boundaries path.disputed {
  stroke-dasharray: 0.5 0.2;
}
  </style>
  <g id="map">
    <path id="background" />
    <g id="graticule"></g>
    <g id="circles"></g>
    <g id="countries"></g>
    <g id="boundaries"></g>
  </g>
</svg>

<script src="complex.min.js"></script>
<script type="module">

import { TWO_PI, DEGS_IN_CIRCLE, deg2Rad } from './math.mjs';
import { Point, LatLon } from './data-types.mjs';
import { MAP_VIEW_ORIGIN, MAP_WIDTH, MAP_HEIGHT, MAP_TILT_DEG, MAP_TILT,
         MAP_AREAS, project } from './concialdi.mjs';
import { getSunLatLon } from './solar-position.mjs';


// ==================================================================
// BASIC CONSTANTS AND FUNCTIONS
// ------------------------------------------------------------------

// DOM function aliases
const fGID   = id       => document.getElementById(id);
const fQS    = selector => document.querySelector(selector);
const fCSVGE = name     => document.createElementNS(SVG_NS, name);

// ------------------------------------------------------------------

// SVG XML namespace
const SVG_NS = 'http://www.w3.org/2000/svg';

// Channels in Canvas data: RGBA
const NUM_CANVAS_DATA_CHANNELS = 4;

// Color channel max value
const MAX_COLOR_VALUE = 255;

// Tilt of the earth's poles in degrees; used to draw the tropic and polar circles
const EARTH_TILT = 23.43;

// ------------------------------------------------------------------

// Simple JSON fetcher
const getJson = filename => fetch(filename).then(response => response.json());


// ==================================================================
// VECTOR MAP LAYERS DRAWING ROUTINES
// ------------------------------------------------------------------

function initVectorMap() {

  fQS('svg').setAttribute('viewBox', `${-MAP_VIEW_ORIGIN.x} ${-MAP_VIEW_ORIGIN.y} ${MAP_WIDTH} ${MAP_HEIGHT}`);
  fGID('map').setAttribute('transform', `rotate(${MAP_TILT_DEG})`);

  drawBackground();
  drawGraticule(10);
  drawSpecialCircles();
  drawCountries();
  drawBoundaries();
}

// ------------------------------------------------------------------

// Convert GeoJSON LineString or MultiPolygon coordinates to an SVG path,
// doing projection along the way
function convertGeoJsonToSvgPath(geoJson, isMultiPolygon) {
  const path = fCSVGE('path');
  const lineStrings = isMultiPolygon ? [].concat(...geoJson) : [geoJson];
  path.setAttribute(
    'd',
    lineStrings
      .map(lineString =>
        lineString
          .map((lonLat, idx) =>
            (idx === 0 ? 'M' : 'L') +
            project(new LatLon(...[...lonLat].reverse())).toString()
          )
          .join('') + (isMultiPolygon ? 'z' : '')
      )
      .join(''),
  );
  return path;
}

// ------------------------------------------------------------------

// Convert a list of list of Point objects to an SVG path
function convertPointListsToSvgPath(pointLists, isClosed) {
  const path = fCSVGE('path');
  path.setAttribute(
    'd',
    pointLists
      .map(list =>
        list.map((point, idx) => (idx === 0 ? 'M' : 'L') + point.toString()).join('') +
        (isClosed ? 'z' : '')
      )
      .join(''),
  );
  return path;
}

// ------------------------------------------------------------------

function drawCountries() {
  getJson('ne-country-areas.json').then(countries => {
    countries.forEach(country => {

      const path = convertGeoJsonToSvgPath(country[1], true);

      // Compute fill color based on the country's position
      // where the average of the country's coordinates is a proxy for position
      const flatLonLatList = [].concat(...[].concat(...country[1]));
      const numCoords = flatLonLatList.length;
      const sumLat = flatLonLatList.reduce((sum, lonLat) => sum + lonLat[1], 0);
      const sumLon = flatLonLatList.reduce((sum, lonLat) => sum + lonLat[0], 0);
      let red   = MAX_COLOR_VALUE/2 * (1 + sumLat / numCoords / (DEGS_IN_CIRCLE/4));
      let green = MAX_COLOR_VALUE/2 * (1 + sumLon / numCoords / (DEGS_IN_CIRCLE/2));
      let blue  = MAX_COLOR_VALUE - (red + green)/2;
      red   = Math.min(MAX_COLOR_VALUE, red   * 1.25);
      green = Math.min(MAX_COLOR_VALUE, green * 1.25);
      blue  = Math.min(MAX_COLOR_VALUE, blue  * 1.25);
      const rgb = `rgb(${red},${green},${blue})`;
      path.setAttribute('fill'  , rgb);
      path.setAttribute('stroke', rgb);

      fGID('countries').appendChild(path);
    });
  });
}

// ------------------------------------------------------------------

function drawBoundaries() {
  getJson('ne-boundaries.json').then(boundaries => {
    boundaries.forEach(boundary => {
      const path = convertGeoJsonToSvgPath(boundary[1], false);
      if (!boundary[0]) path.classList.add('disputed');
      fGID('boundaries').appendChild(path);
    });
  });
}

// ------------------------------------------------------------------

// Graticule interval values in degrees
const DEFAULT_INTERVAL = 15;
const VALID_INTERVALS = [1, 2, 5, 10, 15, 20, 30];

function drawGraticule(interval = DEFAULT_INTERVAL) {

  if (!VALID_INTERVALS.includes(interval)) interval = DEFAULT_INTERVAL;

  const pointLists = [];
  MAP_AREAS.forEach((area, idx) => {

    let points;

    let endLon = area.neCorner.lon;
    if (area.hasAntimeridian) endLon += DEGS_IN_CIRCLE;

    // Generate latitude lines
    for (
      let lat = Math.ceil (area.swCorner.lat/interval)*interval;
      lat <=    Math.floor(area.neCorner.lat/interval)*interval;
      lat += interval
    ) {
      points = [];
      for (let lon = area.swCorner.lon; lon <= endLon; lon++) {
        points.push(project(new LatLon(lat, lon), idx));
      }
      if (area.swCorner.lon % 1 !== endLon % 1) {
        // Account for the half-degree cut along the Bering Strait
        points.push(project(new LatLon(lat, endLon), idx));
      }
      pointLists.push(points);
    }

    // Generate longitude lines
    for (
      let lon = Math.ceil (area.swCorner.lon/interval)*interval;
      lon <=    Math.floor(endLon           /interval)*interval;
      lon += interval
    ) {
      points = [];
      for (let lat = area.swCorner.lat; lat <= area.neCorner.lat; lat++) {
        points.push(project(new LatLon(lat, lon), idx));
      }
      pointLists.push(points);
    }
  });

  // Draw graticule
  const path = convertPointListsToSvgPath(pointLists, false);
  fGID('graticule').appendChild(path);
}

// ------------------------------------------------------------------

// Draws the equator, tropic circles, and polar circles
function drawSpecialCircles() {

  let pointLists;
  let points;
  let path;

  // Generate equator
  pointLists = [];
  points = [];
  points.push(project(MAP_AREAS[0].swCorner));
  points.push(project(MAP_AREAS[1].swCorner));
  points.push(project(MAP_AREAS[2].swCorner));
  points.push(project(MAP_AREAS[3].swCorner));
  points.push(project(MAP_AREAS[4].swCorner));
  points.push(project(MAP_AREAS[0].swCorner, 4));
  pointLists.push(points);
  points = [];
  points.push(project(new LatLon(0, MAP_AREAS[5].swCorner.lon), 5));
  points.push(project(MAP_AREAS[5].neCorner));
  pointLists.push(points);
  points = [];
  points.push(project(MAP_AREAS[4].swCorner));
  points.push(project(MAP_AREAS[11].neCorner, 11));
  pointLists.push(points);

  // Draw equator
  path = convertPointListsToSvgPath(pointLists, false);
  path.classList.add('equator');
  fGID('circles').appendChild(path);

  // Generate Tropic of Cancer and Arctic Circle
  [EARTH_TILT, DEGS_IN_CIRCLE/4 - EARTH_TILT].forEach(lat => {
    points = [project(new LatLon(lat, MAP_AREAS[0].swCorner.lon))];
    for (let lon = Math.trunc(MAP_AREAS[0].swCorner.lon); lon < MAP_AREAS[4].neCorner.lon + DEGS_IN_CIRCLE; lon++) {
      points.push(project(new LatLon(lat, lon)));
    }
    points.push(project(new LatLon(lat, MAP_AREAS[4].neCorner.lon), 4));
    pointLists.push(points);
  });

  // Generate Tropic of Capricorn
  points = [];
  for (let lon = MAP_AREAS[5].swCorner.lon; lon <= MAP_AREAS[6].neCorner.lon; lon++) {
    points.push(project(new LatLon(-EARTH_TILT, lon)));
  }
  pointLists.push(points);
  points = [];
  for (let lon = MAP_AREAS[8].swCorner.lon; lon <= MAP_AREAS[8].neCorner.lon; lon++) {
    points.push(project(new LatLon(-EARTH_TILT, lon), 8));
  }
  pointLists.push(points);
  points = [];
  for (let lon = MAP_AREAS[10].swCorner.lon; lon <= MAP_AREAS[11].neCorner.lon + DEGS_IN_CIRCLE; lon++) {
    points.push(project(new LatLon(-EARTH_TILT, lon), points.length === 0 ? 10 : undefined));
  }
  pointLists.push(points);

  // Generate Antarctic Circle
  points = [];
  for (let lon = MAP_AREAS[5].swCorner.lon; lon <= MAP_AREAS[7].neCorner.lon; lon++) {
    points.push(project(new LatLon(-DEGS_IN_CIRCLE/4 + EARTH_TILT, lon)));
  }
  pointLists.push(points);
  points = [];
  for (let lon = MAP_AREAS[9].swCorner.lon; lon <= MAP_AREAS[11].neCorner.lon + DEGS_IN_CIRCLE; lon++) {
    points.push(project(new LatLon(-DEGS_IN_CIRCLE/4 + EARTH_TILT, lon), points.length === 0 ? 9 : undefined));
  }
  pointLists.push(points);

  // Draw tropic and polar circles
  path = convertPointListsToSvgPath(pointLists, false);
  path.classList.add('polar-tropic');
  fGID('circles').appendChild(path);
}

// ------------------------------------------------------------------

// Draw the map background/outline
function drawBackground() {

  // Generate background points
  const points = [];
  points.push(project(new LatLon(MAP_AREAS[5].neCorner.lat, MAP_AREAS[5].swCorner.lon), 5));
  for (let lat = 0; lat >= -DEGS_IN_CIRCLE/4; lat--) {
    points.push(project(new LatLon(lat, MAP_AREAS[5].swCorner.lon), 5));
  }
  for (let lon = MAP_AREAS[7].neCorner.lon; lon >= MAP_AREAS[7].swCorner.lon; lon--) {
    points.push(project(new LatLon(MAP_AREAS[7].neCorner.lat, lon)));
  }
  points.push(project(MAP_AREAS[6].neCorner, 6));
  for (let lon = MAP_AREAS[8].swCorner.lon; lon <= MAP_AREAS[8].neCorner.lon; lon++) {
    points.push(project(new LatLon(MAP_AREAS[8].swCorner.lat, lon), 8));
  }
  points.push(project(MAP_AREAS[8].neCorner));
  for (let lon = MAP_AREAS[9].neCorner.lon; lon >= MAP_AREAS[9].swCorner.lon; lon--) {
    points.push(project(new LatLon(MAP_AREAS[9].neCorner.lat, lon), 9));
  }
  for (let lat = -DEGS_IN_CIRCLE/4; lat <= 0; lat++) {
    points.push(project(new LatLon(lat, MAP_AREAS[11].neCorner.lon), 11));
  }
  points.push(project(MAP_AREAS[10].neCorner));
  for (let lat = 0; lat < DEGS_IN_CIRCLE/4; lat++) {
    points.push(project(new LatLon(lat, MAP_AREAS[4].neCorner.lon), 4));
  }
  for (let lat = DEGS_IN_CIRCLE/4; lat >= 0; lat--) {
    points.push(project(new LatLon(lat, MAP_AREAS[0].swCorner.lon)));
  }
  points.push(project(MAP_AREAS[5].neCorner));

  // Draw background
  fGID('background').setAttribute(
    'd',
    points.map((point, idx) => (idx === 0 ? 'M' : 'L') + point.toString()).join(''),
  );
}


// ==================================================================
// RASTER MAP DRAWING ROUTINES
// ------------------------------------------------------------------

const NASA_BLUE_FILENAME  = 'nasa-blue-marble-ng.jpg';
const NASA_BLACK_FILENAME = 'nasa-black-marble.jpg';
const NE_I_FILENAME       = 'ne-i.jpg';
const NE_HYPSO_FILENAME   = 'ne-hypso.jpg';

const MIN_TERMINATOR_DISTANCE = deg2Rad(89);
const MAX_TERMINATOR_DISTANCE = deg2Rad(92);

const PIXEL_DENSITY = 2;

// ------------------------------------------------------------------

let Canvas;            // Canvas HTML element
let CanvasCtx;         // Canvas rendering context
let CanvasData;        // Canvas image data
let RasterPpu;         // Ratio of canvas display pixels per SVG length unit
let SourceRasterPpd;   // Source map's pixels per degree measure; must be an integer
let SourceRasterData;  // Source map's raw image data

// Flag that indicates if a terminator should be drawn
let HasTerminator = false;

// Current position of the sun as a LatLon object in radians
let SunPosition;

// ------------------------------------------------------------------

// Class to represent a 1°×1° cell of the raster map
class MapCell {

  constructor(swLatLon, cellCorners, maskCorners) {

    // Original LatLon of the cell's SW corner in degrees
    this.swLatLon = swLatLon;

    // Array of projected coordinates (as Point objects) of the cell corners
    // starting from the SW corner going counterclockwise
    this.cellCorners = cellCorners;

    // Same as above but for the cell mask to account for the half-cells along
    // the Bering Strait cut: we only draw pixels within the mask
    this.maskCorners = maskCorners;

    const isNorthPolar = cellCorners[2].isEqualTo(cellCorners[3]);
    const isSouthPolar = cellCorners[0].isEqualTo(cellCorners[1]);

    // Indicates if this cell is adjacent to the N/S pole
    this.isPolar = isNorthPolar || isSouthPolar;

    // If isPolar, indicates if this cell is adjacent to the N pole
    this.isNorthPolar = isNorthPolar;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  // Draws this cell's portion of the raster map by writing into the global
  // CanvasData object and reading from the SourceRasterData object
  drawCell() {

    const xs = this.maskCorners.map(point => point.x);
    const ys = this.maskCorners.map(point => point.y);
    const minX = Math.floor(Math.min(...xs));
    const maxX = Math.ceil (Math.max(...xs));
    const minY = Math.floor(Math.min(...ys));
    const maxY = Math.ceil (Math.max(...ys));

    for   (let x = minX; x <= maxX; x++) {
      for (let y = minY; y <= maxY; y++) {

        const pixelPos = new Point(x, y);

        if (!this.isInMask(pixelPos)) continue;

        const latLon = this.isPolar
          ? this.getPolarInverseLatLon(pixelPos)
          : this.getInverseLatLon     (pixelPos);
        const pixelOffset = new Point(
          (latLon.lon + DEGS_IN_CIRCLE/2) % DEGS_IN_CIRCLE,
          DEGS_IN_CIRCLE/4 - latLon.lat,
        );
        const srcDataIdx = NUM_CANVAS_DATA_CHANNELS * (
          Math.floor(SourceRasterPpd * pixelOffset.y) * DEGS_IN_CIRCLE * SourceRasterPpd +
          Math.floor(SourceRasterPpd * pixelOffset.x)
        );
        const destDataIdx = NUM_CANVAS_DATA_CHANNELS * (y * Canvas.width + x);

        let pixelData;
        if (HasTerminator) {
          const distance = SunPosition.getDistanceTo(latLon.toRadians());
          const dayRatio =
            distance <= MIN_TERMINATOR_DISTANCE
              ? 1
              : distance >= MAX_TERMINATOR_DISTANCE
                ? 0
                : 1 - (distance - MIN_TERMINATOR_DISTANCE) / (MAX_TERMINATOR_DISTANCE - MIN_TERMINATOR_DISTANCE);
          const nightOffset = NUM_CANVAS_DATA_CHANNELS * DEGS_IN_CIRCLE**2 * SourceRasterPpd**2 / 2;
          pixelData = [
            SourceRasterData[srcDataIdx    ] * dayRatio,
            SourceRasterData[srcDataIdx + 1] * dayRatio,
            SourceRasterData[srcDataIdx + 2] * dayRatio,
          ];
          pixelData[0] += SourceRasterData[nightOffset + srcDataIdx    ] * (1 - dayRatio);
          pixelData[1] += SourceRasterData[nightOffset + srcDataIdx + 1] * (1 - dayRatio);
          pixelData[2] += SourceRasterData[nightOffset + srcDataIdx + 2] * (1 - dayRatio);
        }
        else {
          pixelData = [
            SourceRasterData[srcDataIdx    ],
            SourceRasterData[srcDataIdx + 1],
            SourceRasterData[srcDataIdx + 2],
          ];
        }

        CanvasData.data[destDataIdx    ] = pixelData[0];
        CanvasData.data[destDataIdx + 1] = pixelData[1];
        CanvasData.data[destDataIdx + 2] = pixelData[2];
        CanvasData.data[destDataIdx + 3] = MAX_COLOR_VALUE;
      }
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  // Returns true if the given point lies inside the cell mask.
  // This is implemented as a simplified point-in-polygon algorithm.
  isInMask(point) {
    let numIntersections = 0;
    for (let idx = 0; idx < this.maskCorners.length; idx++) {
      const edgePointA = this.maskCorners[idx];
      const edgePointB = this.maskCorners[(idx + 1) % this.maskCorners.length];
      if (
        point.x >= Math.min(edgePointA.x, edgePointB.x) &&
        point.x <  Math.max(edgePointA.x, edgePointB.x)
      ) {
        if (
          point.y >= Math.max(edgePointA.y, edgePointB.y) ||
          point.y >= Math.min(edgePointA.y, edgePointB.y) &&
          point.y >= edgePointA.y + (point.x - edgePointA.x) / (edgePointB.x - edgePointA.x) * (edgePointB.y - edgePointA.y)
        ) numIntersections++;
      }
    }
    return numIntersections % 2 === 1;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  // Returns the spherical coordinates in degrees as a LatLon object
  // of a given "projected" point inside this cell if cell is not polar
  getInverseLatLon(point) {

    // Given 1°×1° cell with corners in projected map coordinates:
    //   - SW corner = (A, B) = this.cellCorners[0]
    //   - SE corner = (C, D) = this.cellCorners[1]
    //   - NW corner = (E, F) = this.cellCorners[3]
    //   - NE corner = (G, H) = this.cellCorners[2]

    const corners = this.cellCorners;

    // Set of equations determining the "projected" coordinates (x′, y′)
    // of an input relative coordinates in degrees (x, y) into a cell,
    // where (x₀, y₀) and (x₁, y₁) are intermediate coordinates:
    //   1. x₀ = A + (C - A)x
    //      y₀ = B + (D - B)x
    //      x₁ = E + (G - E)x
    //      y₁ = F + (H - F)x
    //   2. x′ = x₀ + (x₁ - x₀)y
    //      y′ = y₀ + (y₁ - y₀)y
    //
    // Equations above combined into a system of 2 equations with unknowns x, y:
    //   x′ - A = (C - A)x + (E - A)y + (A + G - C - E)xy
    //   y′ - B = (D - B)x + (F - B)y + (B + H - D - F)xy
    //
    // Helper coefficients for the system of equations:
    //   J = x′ - A
    //   K = y′ - B
    //   L = C - A
    //   M = D - B
    //   N = E - A
    //   P = F - B
    //   Q = A + G - C - E
    //   R = B + H - D - F

    const J = point.x - corners[0].x;
    const K = point.y - corners[0].y;
    const L = corners[1].x - corners[0].x;
    const M = corners[1].y - corners[0].y;
    const N = corners[3].x - corners[0].x;
    const P = corners[3].y - corners[0].y;
    const Q = corners[0].x + corners[2].x - corners[1].x - corners[3].x;
    const R = corners[0].y + corners[2].y - corners[1].y - corners[3].y;

    // Same system of equations above but using helper coefficients:
    //   J = Lx + Ny + Qxy
    //   K = Mx + Py + Rxy
    //
    // Combined equation in terms of y:
    //   y = (J - Lx)/(N + Qx) = (K - Mx)/(P + Rx)
    //
    // Quadratic equation with variable x:
    //   (-LR + QM)x² + (JR + NM - LP - QK)x + (JP - NK) = 0

    // Quadratic equation coefficients:
    const a =           - L*R + Q*M;
    const b = J*R + N*M - L*P - Q*K;
    const c = J*P - N*K;

    // Determine 2 solutions to the quadratic equation
    const x1 = (-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);
    const x2 = (-b - Math.sqrt(b * b - 4 * a * c)) / (2 * a);
    const y1 = (J - L * x1) / (N + Q * x1);
    const y2 = (J - L * x2) / (N + Q * x2);

    // Return one of the solutions added to the SW corner coordinates
    const latLon = (0 <= x1 && x1 <= 1 && 0 <= y1 && y1 <= 1)
      ? new LatLon(y1, x1)
      : new LatLon(y2, x2);
    latLon.lat += this.swLatLon.lat;
    latLon.lon += this.swLatLon.lon;
    return latLon;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  // Returns the spherical coordinates in degrees as a LatLon object
  // of a given "projected" point inside this cell if cell is polar.
  // The algorithm is basic triangular math assuming that the cell is
  // shaped like an isosceles triangle with the vertex point at the pole.
  getPolarInverseLatLon(point) {

    const corners = this.cellCorners;

    // Compute relative latitude as a function of the ratio of the point's
    // distance to the pole
    const cellHeight = corners[2].getDistanceTo(corners[1]);
    const relLat = this.isNorthPolar
      ? 1 - corners[2].getDistanceTo(point) / cellHeight
      :     corners[1].getDistanceTo(point) / cellHeight;

    // Compute relative longitude as a function of the angle of the point
    // with respect to the pole in relation the the vertex angle
    let cellWidth = this.isNorthPolar
      ? corners[2].getAngleTo(corners[0]) - corners[2].getAngleTo(corners[1])
      : corners[1].getAngleTo(corners[2]) - corners[1].getAngleTo(corners[3]);
    if (cellWidth < 0) cellWidth += TWO_PI;
    let relLon = this.isNorthPolar
        ? +(corners[2].getAngleTo(corners[0]) - corners[2].getAngleTo(point))
        : -(corners[1].getAngleTo(corners[3]) - corners[1].getAngleTo(point));
    if (relLon < 0) relLon += TWO_PI;
    relLon /= cellWidth;

    return new LatLon(this.swLatLon.lat + relLat, this.swLatLon.lon + relLon);
  }
}

// ------------------------------------------------------------------

function initRasterMap(filename, renderTerminator) {

  Canvas = fQS('canvas');
  Canvas.width = Canvas.clientWidth * PIXEL_DENSITY;
  RasterPpu = Canvas.width / MAP_WIDTH;
  Canvas.height = RasterPpu * MAP_HEIGHT;
  CanvasCtx = Canvas.getContext('2d');
  CanvasData = CanvasCtx.getImageData(0, 0, Canvas.width, Canvas.height);

  if (renderTerminator) {

    HasTerminator = true;

    SunPosition = getSunLatLon().toRadians();

    let numImagesLoaded = 0;
    let daySourceImage, nightSourceImage;  // Predeclare

    const renderRasterMap = function() {

      SourceRasterPpd = daySourceImage.width / DEGS_IN_CIRCLE;
      const sourceCanvas = document.createElement('canvas');
      sourceCanvas.width = daySourceImage.width;
      sourceCanvas.height = daySourceImage.height * 2;
      const sourceCtx = sourceCanvas.getContext('2d')
      sourceCtx.drawImage(daySourceImage, 0, 0);
      sourceCtx.drawImage(nightSourceImage, 0, daySourceImage.height);
      SourceRasterData = sourceCtx.getImageData(0, 0, daySourceImage.width, daySourceImage.height * 2).data;

      MAP_AREAS.forEach((area, idx) => { drawRasterMapArea(area, idx) });
      CanvasCtx.putImageData(CanvasData, 0, 0);
    };

    const onloadHandler = function() {
      numImagesLoaded++;
      if (numImagesLoaded === 2) renderRasterMap();
    }

    daySourceImage   = new Image();
    nightSourceImage = new Image();
    daySourceImage.src   = NASA_BLUE_FILENAME;
    nightSourceImage.src = NASA_BLACK_FILENAME;
    daySourceImage.onload   = onloadHandler;
    nightSourceImage.onload = onloadHandler;
  }
  else {
    const sourceImage = new Image();
    sourceImage.src = filename;
    sourceImage.onload = function() {

      SourceRasterPpd = sourceImage.width / DEGS_IN_CIRCLE;
      const sourceCanvas = document.createElement('canvas');
      sourceCanvas.width = sourceImage.width;
      sourceCanvas.height = sourceImage.height;
      const sourceCtx = sourceCanvas.getContext('2d')
      sourceCtx.drawImage(sourceImage, 0, 0);
      SourceRasterData = sourceCtx.getImageData(0, 0, sourceImage.width, sourceImage.height).data;

      MAP_AREAS.forEach((area, idx) => { drawRasterMapArea(area, idx) });
      CanvasCtx.putImageData(CanvasData, 0, 0);
    };
  }
}

// ------------------------------------------------------------------

// Draws a portion of a raster map corresponding to a given MapArea and its
// index by iterating over the MapArea's 1°×1° cells
function drawRasterMapArea(area, idx) {
  for (let lat = area.swCorner.lat; lat < area.neCorner.lat; lat++) {

    // Account for the antimeridian and the Bering Strait half-cells
    const antiMeridianAdjust = area.hasAntimeridian ? DEGS_IN_CIRCLE : 0;
    const startLon = Math.floor(area.swCorner.lon);
    const endLon   = Math.ceil (area.neCorner.lon) + antiMeridianAdjust;

    for (let lon = startLon; lon < endLon; lon++) {

      const maskedLonW = Math.max(lon    , area.swCorner.lon);
      const maskedLonE = Math.min(lon + 1, area.neCorner.lon + antiMeridianAdjust);

      const cornerPositions =
        // Raw 2D list of spherical coordinates of the corners
        // starting from the SW corner going counterclockwise
        [
          // Cell corners
          [lat    , lon    ],
          [lat    , lon + 1],
          [lat + 1, lon + 1],
          [lat + 1, lon    ],
          // Cell mask corners
          [lat    , maskedLonW],
          [lat    , maskedLonE],
          [lat + 1, maskedLonE],
          [lat + 1, maskedLonW],
        ]
        .map(coords => new LatLon(...coords))
        // Do initial projection into map coordinates then rotate, translate,
        // and scale into final map coordinates (in Canvas pixels)
        .map(latLon =>
          project(latLon, idx)
          .rotate(MAP_TILT)
          .translate(MAP_VIEW_ORIGIN)
          .scale(RasterPpu)
        );

      const cell = new MapCell(
        new LatLon(lat, lon),
        cornerPositions.slice(0, 4),
        cornerPositions.slice(4, 8),
      );
      cell.drawCell();
    }
  }
}


// ==================================================================
// RUN THE APP
// ------------------------------------------------------------------

initVectorMap();
//initRasterMap(NE_HYPSO_FILENAME);
//initRasterMap(null, true);

</script>
</body>
</html>
